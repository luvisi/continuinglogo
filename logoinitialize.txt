
to pick :thing
  output item ((ifelse arrayp :thing [first :thing] [1]) + ~
               random count :thing) ~
              :thing
end
bury "pick

; A word is the name of a property list if it has a non-empty
; property list.
to plistp :thing
  if wordp :thing [output (plist :thing) <> []]
  output "false
end
bury "plistp

copydef "plist? "plistp
bury "plist?

; save_source_helper prints only the LINE objects in :body.
; Typical uses will include:
;   :printer is TYPE and :getter is LINE_RAW for printing the
;   raw version of a procedure.  This will happen when the procedure
;   was defined using TO.
;
;   :printer is PRINT and :getter is LINE_PARSED for printing the
;   parsed version of a procedure.  This will happen when the procedure
;   was defined using DEFINE.
;
to save_source_helper :printer :getter :body
  if :body = [] [stop]
  if linep first :body [invoke :printer invoke :getter first :body]
  save_source_helper :printer :getter butfirst :body
end
bury "save_source_helper

; These add colons to variables when generating the TO line while
; saving a procedure that was defined using DEFINE.
to save_source.maybe.addcolon :arg
    if wordp :arg [
        if or emptyp :arg (first :arg) <> ": [op word ": :arg]
        op :arg
    ]
    if listp :arg [op fput save_source.maybe.addcolon first :arg bf :arg]
    op :arg
end
bury "save_source.maybe.addcolon

to save_source.addcolons :args
    op map "save_source.maybe.addcolon :args
end
bury "save_source.addcolons


; This prints out the source for a procedure.
; If the procedure was defined using TO, then we can just
; print the raw version of each line, as originally entered.
;
; If the procedure was defined using DEFINE, then we need to
; do some extra work to generate the TO line, and we also need to
; print out the body with FULLPRINTP set to TRUE.
to save_source :proc
  localmake "source symbol_source :proc

  if :source = [] [
    ; We have no source to print.  Generate an empty definition.
    print (list "to :proc)
    print "end
    print "
    stop
  ]

  if (line_raw first :source) = [] [
      ; We have no raw input, meaning the procedure was probably
      ; created with DEFINE.  We need to create a new TO line and
      ; print the parsed version of each LINE object in the definition.
      localmake "fullprintp "true
      localmake "first_line line_parsed first :source
      print (se "to :proc save_source.addcolons bf bf :first_line)
      save_source_helper "print "line_parsed bf :source
  ] [
      ; We have raw input, meaning the procedure was probably defined
      ; normally with TO.  We type out the raw input.
      localmake "fullprintp "false
      save_source_helper "type "line_raw :source
  ]
  print "end
  print "
end
bury "save_source

to quote_if_name :thing
  if and wordp :thing not numberp :thing [output word "" :thing]
  output :thing
end
bury "quote_if_name

to save_plist_helper :name :l
  if :l = [] [stop]
  (show "pprop word "" :name quote_if_name first :l ~
                             quote_if_name first butfirst :l)
  save_plist_helper :name butfirst butfirst :l
end
bury "save_plist_helper

to save_plist :name
  localmake "fullprintp "true
  save_plist_helper :name plist :name
end
bury "save_plist

to save_name :name
  localmake "fullprintp "true
  if not namep :name [stop]
  (show "make word "" :name quote_if_name thing :name)
end
bury "save_name
  
; Print Out Names
to pon :names
  if :names = [] [stop]
  if wordp :names [save_name :names stop]
  save_name first :names
  pon butfirst :names
end
bury "pon

; Print Out Property Lists
to popl :names
  if :names = [] [stop]
  if wordp :names [save_plist :names stop]
  save_plist first :names
  popl butfirst :names
end
bury "popl

; Prints out Logo code to recreate the things in :contentslist.
; If :contentslist is a word, it is treated as the name of a procedure.
; If :contentslist is a list of words, it is treated as a list of
; procedure names.
; If :contents is a list of up to three lists, they are treated as:
;    a list of procedure names.
;    a list of variable names.
;    a list of property list names.
to printout :contentslist
  if :contentslist = [] [stop]
  if wordp :contentslist [save_source :contentslist stop]
  if wordp first :contentslist [
      save_source first :contentslist
      printout butfirst :contentslist
      stop
  ]
  printout first :contentslist
  make "contentslist butfirst :contentslist
  if not emptyp :contentslist [
      pon first :contentslist
      make "contentslist butfirst :contentslist
  ]
  if not emptyp :contentslist [
      popl first :contentslist
  ]
end
bury "printout

copydef "po "printout
bury "po

; Prints out just the title line of a procedure.
to pot.print.title :proc
  localmake "source symbol_source :proc

  ; If we have no source code, we generate a new title line.
  if :source = [] [
    print (list "to :proc)
    stop
  ]

  if (line_raw first :source) = [] [
      ; If we have no raw source, we generate it from the parsed version.
      ; This happens with procedures created with DEFINE.
      localmake "fullprintp "true
      localmake "first_line line_parsed first :source
      print (se "to :proc save_source.addcolons bf bf :first_line)
  ] [
      ; If we have a raw title line, then we just print it out.
      ; This happens whith procedures created with TO.
      localmake "fullprintp "false
      type line_raw first :source
  ]
end
bury "pot.print.title

; Print Out Titles
; Like PRINTOUT, but only prints the title TO line for procedures.
; If :contentslist is a word, it is treated as the name of a procedure.
; If :contentslist is a list of words, it is treated as a list of
; procedure names.
; If :contents is a list of up to three lists, they are treated as:
;    a list of procedure names.
;    a list of variable names.
;    a list of property list names.
to pot :contentslist
  if :contentslist = [] [stop]
  if wordp :contentslist [pot.print.title :contentslist stop]
  if wordp first :contentslist [
      pot.print.title first :contentslist
      pot butfirst :contentslist
      stop
  ]
  pot first :contentslist
  make "contentslist butfirst :contentslist
  if not emptyp :contentslist [
      pon first :contentslist
      make "contentslist butfirst :contentslist
  ]
  if not emptyp :contentslist [
      popl first :contentslist
  ]
end
bury "pot


.macro savecontents :file :contents
  output (list "openwrite word "" :file          ~
               "setwrite word "" :file           ~
               "printout quote_if_name :contents ~
               "setwrite []                      ~
               "close word "" :file              ~
               "print ""Saved)
end
bury "savecontents

.macro save :file
  output (list "savecontents quote_if_name :file "contents)
end
bury "save

to load.helper
  local "startup
  logo
  if namep "startup [run :startup]
end
bury "load.helper

.macro load :file
  localmake "oldreader reader
  output (list "openread word "" :file    ~
               "setread word "" :file     ~
               "load.helper               ~
               "setread quoted :oldreader ~
               "close word "" :file       ~
               "print ""Loaded)
end
bury "load

to pause_caller :paused.procedure
    pause
end
bury "pause_caller

to pause
    local "pause.error
    localmake "pause.saved.input reader
    localmake "pause.saved.output writer
    setread []
    setwrite []
    localmake "result ~
        runresult [catch "pause [
           while ["true] [
               catch "error [logo]
               make "pause.error error
               if :pause.error <> [] [print :pause.error]]]]
    setread :pause.saved.input
    setwrite :pause.saved.output
    if :result <> [] [output first :result]
end
bury "pause

to continue [:args]
    if :args <> [] [(throw "pause first :args)]
    throw "pause
end
bury "continue

.macro c [:args]
    output (sentence "\( "continue map "quote_if_name :args "\) )
end
bury "c

.macro while :while.cond :while.instr
  op (list "if "run quoted :while.cond ~
               (list "run quoted :while.instr ~
                     "while quoted :while.cond quoted :while.instr))
end
bury "while

; Reads the entire input file, until an EOF, using READLIST on each
; line.  Returns a list of lists, with one list for each line.
to read_lines_readlist
    localmake "line readlist
    if :line = " [output []]
    output fput :line read_lines_readlist
end
bury "read_lines_readlist

; Reads the entire input file, until an EOF, using READWORD on each line.
; Returns a list of words, with one word for each line.
to read_lines_readword
    localmake "line readword
    if :line = [] [output []]
    output fput :line read_lines_readword
end
bury "read_lines_readword

; Runs :command and returns the result.
; By default, the return value is a list of lists, with each
; line read by READLIST.
; If :wordflag is provided, regardless of value, then the result
; is a list of words, with one word for each line in the output
; of :command.
to shell :command [:wordflag]
    localmake "oldreader reader
    local "result
    openshell "shellfile :command
    setread "shellfile
    ifelse emptyp :wordflag [
        make "result read_lines_readlist
    ] [
        make "result read_lines_readword
    ]
    setread :oldreader
    close "shellfile
    output :result
end
bury "shell

; Set the editor to be used when editing procedures, variables, or property
; lists with EDIT.
to seteditor :e
    make "edit.editor :e
end
bury "seteditor


; Get the editor to be used when editing procedures, variables, or property
; lists with EDIT.
; :edit.editor is used if it is set, then we try the VISUAL and EDITOR
; environment variables, and finally we default to vi.
to edit.editor
    if namep "edit.editor [output :edit.editor]
    localmake "editor getenv "VISUAL
    if :editor <> [] [output :editor]
    make "editor getenv "EDITOR
    if :editor <> [] [output :editor]
    output "vi
end
bury [[edit.editor] [edit.editor]]

; Edit the procedures, variables, and property lists in
; :contentslist.
; This is done by saving the definitions to a temp file, editing the
; file, and then loading the file.
to edit :contentslist [:tmp "logo.temp.txt]
    savecontents :tmp :contentslist
    localmake "status system (list edit.editor :tmp)
    if :status <> 0 [throw "error [edit error]]
    load :tmp
end
bury "edit

; Edit an existing file, and then reload it.
; This is useful for editing, then testing, then editing, then testing
; a set of definitions.
to editfile :file
    localmake "status system (list edit.editor :file)
    if :status <> 0 [throw "error [edit error]]
    load :file
end
bury "editfile

copydef "ed "edit
bury "ed

; Pull out the definition of :proc in a format suitable for
; DEFINE, that is, a list of parsed lines whose first element
; is a list of arguments.
to text :proc
    localmake "source symbol_source :proc
    localmake "args bf bf line_parsed first :source ; Skip "to <name>"
    localmake "body map [line_parsed ?] bf :source
    op fput :args :body
end
bury "text

; Return the raw text of a procedure.  If it was defined with
; TO, then this is the exact text used to define the procedure.
; Otherwise, returns parsed versions of the lines.
to rawtext :proc
    localmake "source symbol_source :proc
    if (line_raw first :source) = [] [
        op map [line_parsed ?] :source
    ] [
        op map [line_raw ?] :source
    ]
end
bury "rawtext
    
; Returns all unburied procedures.
to procedures
    op first contents
end
bury "procedures

; Returns all primitives.  This includes procedures defined in
; lisp.
to primitives
    op filter "primitivep oblist
end
bury "primitives

; Returns all unburied variable names in a contents list.
to names
    op (list [] first bf contents)
end
bury "names

; Returns all unburied property list names in a contents list.
to plists
    op (list [] [] first bf bf contents)
end
bury "plists

; Returns the current repetition count for the innermost REPEAT or FOREVER.
to repcount
  op :repcount
end
bury "repcount

.macro repeat.helper :current.count :count :block
  if :current.count < :count [
    op (list "invoke "fput [repcount] :block :current.count ~
        "repeat.helper :current.count+1 :count :block)
  ] 
  if :current.count = :count [
    op (list "invoke "fput [repcount] :block :current.count)
  ]
  op []
end
bury "repeat.helper

.macro repeat :count :block
    op (list "repeat.helper 1 :count :block)
end
bury "repeat

.macro forever.helper :current.count :block
  op (list "invoke "fput [repcount] :block :current.count ~
      "forever.helper :current.count+1 :block)
end
bury "forever.helper
  
.macro forever :block
  op (list "forever.helper 1 :block)
end
bury "forever

; Erase all unburied procedures, variables names, and property lists.
to erall
  erase contents
end
bury "erall

; Erase all unburied procedures.
to erps
  erase procedures
end
bury "erps

; Erase all unburied variable names.
to erns
  erase names
end
bury "erns

; Erase all unburied variable property lists.
to erpls
  erase plists
end
bury "erpls

to lput :thing :group
  if wordp :group [op word :group :thing]
  if listp :group [op se :group (list :thing)]
  throw "error (word "|Bad argument to lput: | :group)
end
bury "lput

to firsts :l
  op map "first :l
end
bury "firsts

to butfirsts :l
  op map "butfirst :l
end
bury "butfirsts

copydef "bfs "butfirsts
bury "bfs

; McCarthy's Ambiguous Operator.
; Returns the first argument.
; If FAIL is called later in the program, then control returns
; to this procedure, and it returns the next argument.
; If it is out of arguments, then it fails, causing any previous
; instance of AMB to resume.
; If there are no previous instances left to resume, then we throw
; an error.

make "amb.continuation [(throw "error "|amb: Out of alternatives|)]
to amb [:values]
    output callcc [[return]
        localmake "amb.old.continuation :amb.continuation
        make "amb.continuation callcc [[resume] :resume]
        if emptyp :values [
            make "amb.continuation :amb.old.continuation
            invoke :amb.continuation :amb.continuation
        ]
        localmake "ret first :values
        make "values butfirst :values
        invoke :return :ret
    ]
end
bury [[amb] [amb.continuation]]

to fail
  (amb)
end
bury "fail

;to #
;  op :template.number
;end
;bury "#

; Ignore case by default.
make "caseignoredp "true
bury [[] [caseignoredp]]

(print [Welcome to ContinuingLogo version] :logoversion)
bury [[] [logoversion]]
